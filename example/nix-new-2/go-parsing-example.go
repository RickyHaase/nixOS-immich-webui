package main

import (
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

// NixConfig represents the same structure you're already using
// This shows how parsing becomes much more reliable with consistent format
type NixConfig struct {
	TimeZone     string
	AutoUpgrade  bool
	UpgradeTime  string
	UpgradeLower string
	UpgradeUpper string
	Tailscale    bool
	TSAuthkey    string
	Email        string
	EmailPass    bool
}

const variablesFile = "variables.nix"

// ===== IMPROVED PARSING FUNCTIONS =====

// parseNixString extracts a string value from consistent Nix format
// Pattern: variableName = "value";
func parseNixString(content, varName string) (string, error) {
	// Much simpler regex because format is consistent
	pattern := fmt.Sprintf(`%s\s*=\s*"([^"]+)"\s*;`, regexp.QuoteMeta(varName))
	re := regexp.MustCompile(pattern)
	
	match := re.FindStringSubmatch(content)
	if len(match) < 2 {
		return "", fmt.Errorf("variable %s not found", varName)
	}
	
	return match[1], nil
}

// parseNixBool extracts a boolean value from consistent Nix format
// Pattern: variableName = true|false;
func parseNixBool(content, varName string) (bool, error) {
	pattern := fmt.Sprintf(`%s\s*=\s*(true|false)\s*;`, regexp.QuoteMeta(varName))
	re := regexp.MustCompile(pattern)
	
	match := re.FindStringSubmatch(content)
	if len(match) < 2 {
		return false, fmt.Errorf("variable %s not found", varName)
	}
	
	return match[1] == "true", nil
}

// ===== MAIN PARSING FUNCTION =====

// LoadCurrentConfig reads variables.nix and parses all values
// This replaces your current loadCurrentConfig() with much simpler logic
func LoadCurrentConfig() (*NixConfig, error) {
	// Read the variables.nix file
	content, err := os.ReadFile(variablesFile)
	if err != nil {
		return nil, fmt.Errorf("failed to read %s: %w", variablesFile, err)
	}
	
	contentStr := string(content)
	config := &NixConfig{}
	
	// Parse all variables - much simpler than current approach
	config.TimeZone, err = parseNixString(contentStr, "timeZone")
	if err != nil {
		return nil, fmt.Errorf("error parsing timeZone: %w", err)
	}
	
	config.AutoUpgrade, err = parseNixBool(contentStr, "autoUpgrade")
	if err != nil {
		return nil, fmt.Errorf("error parsing autoUpgrade: %w", err)
	}
	
	config.UpgradeTime, err = parseNixString(contentStr, "upgradeTime")
	if err != nil {
		return nil, fmt.Errorf("error parsing upgradeTime: %w", err)
	}
	
	config.UpgradeLower, err = parseNixString(contentStr, "upgradeLower")
	if err != nil {
		return nil, fmt.Errorf("error parsing upgradeLower: %w", err)
	}
	
	config.UpgradeUpper, err = parseNixString(contentStr, "upgradeUpper")
	if err != nil {
		return nil, fmt.Errorf("error parsing upgradeUpper: %w", err)
	}
	
	config.Tailscale, err = parseNixBool(contentStr, "tailscaleEnable")
	if err != nil {
		return nil, fmt.Errorf("error parsing tailscaleEnable: %w", err)
	}
	
	config.TSAuthkey, err = parseNixString(contentStr, "tsAuthKey")
	if err != nil {
		return nil, fmt.Errorf("error parsing tsAuthKey: %w", err)
	}
	
	config.Email, err = parseNixString(contentStr, "emailAddress")
	if err != nil {
		return nil, fmt.Errorf("error parsing emailAddress: %w", err)
	}
	
	config.EmailPass, err = parseNixBool(contentStr, "emailPasswordSet")
	if err != nil {
		return nil, fmt.Errorf("error parsing emailPasswordSet: %w", err)
	}
	
	return config, nil
}

// ===== GENERATION FUNCTION =====

// GenerateVariablesNix creates the variables.nix file from config
// This replaces your template-based approach with string building
func GenerateVariablesNix(config *NixConfig) (string, error) {
	// Build the variables.nix content
	var sb strings.Builder
	
	sb.WriteString("# variables.nix - Generated by nixOS-immich-webui\n")
	sb.WriteString("{\n")
	sb.WriteString("  # System Configuration Variables\n")
	sb.WriteString(fmt.Sprintf("  timeZone = %q;\n", config.TimeZone))
	sb.WriteString(fmt.Sprintf("  autoUpgrade = %s;\n", boolToNix(config.AutoUpgrade)))
	sb.WriteString(fmt.Sprintf("  upgradeTime = %q;\n", config.UpgradeTime))
	sb.WriteString(fmt.Sprintf("  upgradeLower = %q;\n", config.UpgradeLower))
	sb.WriteString(fmt.Sprintf("  upgradeUpper = %q;\n", config.UpgradeUpper))
	sb.WriteString("\n")
	sb.WriteString("  # Remote Access Variables\n")
	sb.WriteString(fmt.Sprintf("  tailscaleEnable = %s;\n", boolToNix(config.Tailscale)))
	sb.WriteString(fmt.Sprintf("  tsAuthKey = %q;\n", config.TSAuthkey))
	sb.WriteString("\n")
	sb.WriteString("  # Email Configuration Variables\n")
	sb.WriteString(fmt.Sprintf("  emailAddress = %q;\n", config.Email))
	sb.WriteString(fmt.Sprintf("  emailPasswordSet = %s;\n", boolToNix(config.EmailPass)))
	sb.WriteString("\n")
	sb.WriteString("  # Static Configuration\n")
	sb.WriteString("  hostName = \"immich\";\n")
	sb.WriteString("  hostId = \"12345678\";\n")
	sb.WriteString("  zfsPoolName = \"tank\";\n")
	sb.WriteString("  immichWorkingDir = \"/root/immich-app\";\n")
	sb.WriteString("  immichTimeout = \"90\";\n")
	sb.WriteString("  adminPanelPort = 8080;\n")
	sb.WriteString("  webPublicPort = 80;\n")
	sb.WriteString("  immichInternalPort = 2283;\n")
	sb.WriteString("}\n")
	
	return sb.String(), nil
}

// boolToNix converts Go bool to Nix boolean string
func boolToNix(b bool) string {
	if b {
		return "true"
	}
	return "false"
}

// ===== BACKUP FUNCTIONS =====

// BackupVariables creates a .old backup of current variables.nix
// This fits your existing backup workflow
func BackupVariables() error {
	if _, err := os.Stat(variablesFile); os.IsNotExist(err) {
		// No existing file to backup
		return nil
	}
	
	content, err := os.ReadFile(variablesFile)
	if err != nil {
		return fmt.Errorf("failed to read current variables: %w", err)
	}
	
	err = os.WriteFile(variablesFile+".old", content, 0644)
	if err != nil {
		return fmt.Errorf("failed to create backup: %w", err)
	}
	
	return nil
}

// RestoreFromBackup restores variables.nix from .old file
// Simple rollback functionality
func RestoreFromBackup() error {
	backupFile := variablesFile + ".old"
	if _, err := os.Stat(backupFile); os.IsNotExist(err) {
		return fmt.Errorf("no backup file found: %s", backupFile)
	}
	
	content, err := os.ReadFile(backupFile)
	if err != nil {
		return fmt.Errorf("failed to read backup: %w", err)
	}
	
	err = os.WriteFile(variablesFile, content, 0644)
	if err != nil {
		return fmt.Errorf("failed to restore from backup: %w", err)
	}
	
	return nil
}

// ===== INTEGRATION WITH EXISTING WORKFLOW =====

// SaveAndApplyConfig combines generation, backup, and your existing apply functions
// This shows how to integrate with your current switchConfig() and applyChanges()
func SaveAndApplyConfig(config *NixConfig) error {
	// 1. Generate new variables.nix content
	content, err := GenerateVariablesNix(config)
	if err != nil {
		return fmt.Errorf("failed to generate config: %w", err)
	}
	
	// 2. Backup current variables.nix
	if err := BackupVariables(); err != nil {
		return fmt.Errorf("failed to backup current config: %w", err)
	}
	
	// 3. Write new variables.nix
	if err := os.WriteFile(variablesFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write new config: %w", err)
	}
	
	// 4. Your existing functions would work here:
	// if err := switchConfig(); err != nil { ... }
	// if err := applyChanges(); err != nil { ... }
	
	fmt.Println("Configuration saved successfully")
	return nil
}

// ===== EXAMPLE USAGE =====

func main() {
	fmt.Println("=== Modular Nix Configuration with Direct Parsing ===")
	
	// Example 1: Parse current configuration
	fmt.Println("\n1. Parsing current configuration:")
	if _, err := os.Stat(variablesFile); err == nil {
		config, err := LoadCurrentConfig()
		if err != nil {
			fmt.Printf("Error parsing config: %v\n", err)
		} else {
			fmt.Printf("Current timezone: %s\n", config.TimeZone)
			fmt.Printf("Auto-upgrade enabled: %v\n", config.AutoUpgrade)
			fmt.Printf("Tailscale enabled: %v\n", config.Tailscale)
		}
	} else {
		fmt.Println("No variables.nix file found")
	}
	
	// Example 2: Generate new configuration
	fmt.Println("\n2. Generating new configuration:")
	newConfig := &NixConfig{
		TimeZone:     "Europe/Berlin",
		AutoUpgrade:  true,
		UpgradeTime:  "03:00",
		UpgradeLower: "03:30",
		UpgradeUpper: "04:00",
		Tailscale:    true,
		TSAuthkey:    "tskey-auth-example123",
		Email:        "admin@example.com",
		EmailPass:    true,
	}
	
	content, err := GenerateVariablesNix(newConfig)
	if err != nil {
		fmt.Printf("Error generating config: %v\n", err)
	} else {
		fmt.Printf("Generated variables.nix (%d bytes)\n", len(content))
	}
	
	fmt.Println("\n=== Benefits of This Approach ===")
	fmt.Println("✅ Simple regex on consistent format (reliable)")
	fmt.Println("✅ Leverages your existing switchConfig/applyChanges")
	fmt.Println("✅ NixOS-native (no JSON conversion)")
	fmt.Println("✅ Modular organization (clear separation)")
	fmt.Println("✅ Simple backup (.old files)")
	fmt.Println("✅ Only variables.nix needs templating")
	fmt.Println("✅ Fits established user workflow")
}

/*
INTEGRATION NOTES:

1. Replace loadCurrentConfig() with LoadCurrentConfig()
   - Much simpler parsing logic
   - More reliable due to consistent format
   - Better error messages

2. Replace template system with GenerateVariablesNix()
   - No more Go templates in embed.FS
   - Direct string building with proper escaping
   - Only one file needs generation

3. Keep your existing functions:
   - switchConfig() works unchanged
   - applyChanges() works unchanged  
   - CopyFile() works unchanged

4. Simple backup strategy:
   - variables.nix.old (main config)
   - admin.nix.old (user additions)
   - Fits your current workflow

5. Modular benefits:
   - Easy to enable/disable modules
   - Clear organization
   - Matches your documentation approach
   - Users manually import (established process)
*/