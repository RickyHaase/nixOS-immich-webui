# configuration.nix - Static NixOS configuration using imported JSON variables
# This file contains NO Go template variables - it's pure NixOS configuration

{ config, pkgs, ... }:

let
  # Access the imported variables from variables.nix
  vars = config.immichVariables;
in
{
  imports = [
    # Hardware configuration (generated by nixos-generate-config)
    ./hardware-configuration.nix
    # Import our variables module
    ./variables.nix
  ];

  # ========== DEFAULT NIXOS CONFIGURATIONS ==========
  # These rarely change and don't need to be user-configurable
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;
  networking.networkmanager.enable = true;
  
  # Locale settings
  i18n.defaultLocale = "en_US.UTF-8";
  i18n.extraLocaleSettings = {
    LC_ADDRESS = "en_US.UTF-8";
    LC_IDENTIFICATION = "en_US.UTF-8";
    LC_MEASUREMENT = "en_US.UTF-8";
    LC_MONETARY = "en_US.UTF-8";
    LC_NAME = "en_US.UTF-8";
    LC_NUMERIC = "en_US.UTF-8";
    LC_PAPER = "en_US.UTF-8";
    LC_TELEPHONE = "en_US.UTF-8";
    LC_TIME = "en_US.UTF-8";
  };
  
  # Keyboard layout
  services.xserver.xkb = {
    layout = "us";
    variant = "";
  };
  
  # Default user
  users.users.testuser = {
    isNormalUser = true;
    description = "Test User";
    extraGroups = [ "networkmanager" "wheel" ];
    packages = with pkgs; [];
  };
  
  # NixOS state version
  system.stateVersion = "24.11";

  # ========== SYSTEM CONFIGURATION ==========
  # All values come from JSON variables - no more scattered template variables!
  time.timeZone = vars.system.timeZone;

  # Automatic system upgrades
  system.autoUpgrade = {
    enable = vars.system.autoUpgrade;
    dates = vars.system.upgradeTime;
    flags = [
      "--update-input"
      "nixpkgs"
      "-L" # print build logs
    ];
    randomizedDelaySec = "15min";
    allowReboot = vars.system.autoUpgrade;
    rebootWindow = {
      lower = vars.system.upgradeLower;
      upper = vars.system.upgradeUpper;
    };
  };

  # ========== NETWORKING CONFIGURATION ==========
  networking.hostName = vars.networking.hostName;
  networking.hostId = vars.networking.hostId;  # Required for ZFS

  # Avahi (mDNS) service discovery
  services.avahi = {
    enable = true;
    openFirewall = true;
    hostName = vars.networking.hostName;
    publish = {
      enable = true;
      addresses = true;
    };
    extraServiceFiles = {
      immich = ''
        <service-group>
          <name replace-wildcards="yes">%h</name>
          <service>
           <type>_http._tcp</type>
           <port>${toString vars.ports.webPublic}</port>
          </service>
        </service-group>
      '';
    };
  };

  # Caddy reverse proxy
  services.caddy = {
    enable = true;
    virtualHosts = {
      # Public Immich access
      "${vars.networking.hostName}.local:${toString vars.ports.webPublic}" = {
        extraConfig = ''
          reverse_proxy http://localhost:${toString vars.ports.immichInternal}
        '';
      };
      # Admin panel access
      ":${toString vars.ports.adminPanel}" = {
        extraConfig = ''
          reverse_proxy http://localhost:8000
        '';
      };
    };
  };

  # Firewall configuration
  networking.firewall = {
    allowPing = vars.firewall.allowPing;
    allowedTCPPorts = vars.firewall.allowedTCPPorts;
  };

  # ========== ZFS CONFIGURATION ==========
  boot.supportedFilesystems = [ "zfs" ];
  boot.zfs = {
    forceImportRoot = false;
    extraPools = [ vars.storage.zfs.poolName ];
  };

  # ZFS maintenance
  services.zfs.autoScrub = {
    enable = vars.storage.zfs.autoScrub;
    pools = [ vars.storage.zfs.poolName ];
  };

  # Snapshot management
  services.sanoid = {
    enable = true;
    interval = "hourly";
    datasets = {
      "${vars.storage.zfs.poolName}" = {
        recursive = true;
        autoprune = true;
        autosnap = true;
        hourly = vars.storage.zfs.snapshots.hourly;
        daily = vars.storage.zfs.snapshots.daily;
        weekly = vars.storage.zfs.snapshots.weekly;
        monthly = vars.storage.zfs.snapshots.monthly;
        yearly = vars.storage.zfs.snapshots.yearly;
      };
    };
  };

  # ========== IMMICH CONFIGURATION ==========
  virtualisation.docker = {
    enable = true;
    autoPrune = {
      enable = true;
      dates = vars.immich.autoPruneSchedule;
    };
  };

  # Required packages
  environment.systemPackages = with pkgs; [
    wget
    zip  # Required for backup functionality
  ];

  # Immich systemd service
  systemd.services.immich-app = {
    description = "Manage Immich Docker Compose Stack";
    requires = [ "docker.service" ];
    after = [ "docker.service" ];
    wantedBy = [ "multi-user.target" ];

    serviceConfig = {
      Type = "simple";
      ExecStart = "${pkgs.docker}/bin/docker compose up";
      ExecStop = "${pkgs.docker}/bin/docker compose down";
      Restart = "always";
      WorkingDirectory = vars.immich.workingDirectory;
      TimeoutStopSec = vars.immich.dockerTimeout;
    };
  };

  # ========== REMOTE ACCESS CONFIGURATION ==========
  # Tailscale VPN
  services.tailscale.enable = vars.remoteAccess.tailscale.enable;

  # Automatic Tailscale connection
  systemd.services.tailscale-autoconnect = {
    description = "Automatic connection to Tailscale";
    after = [ "network-pre.target" "tailscale.service" ];
    wants = [ "network-pre.target" "tailscale.service" ];
    wantedBy = [ "multi-user.target" ];
    serviceConfig.Type = "oneshot";

    script = with pkgs; ''
      # Wait for tailscaled to settle
      sleep 2

      # Check if already authenticated to tailscale
      status="$(${tailscale}/bin/tailscale status -json | ${jq}/bin/jq -r .BackendState)"
      if [ $status = "Running" ]; then
        exit 0
      fi

      # Authenticate with tailscale using auth key from variables
      ${tailscale}/bin/tailscale up -authkey ${vars.remoteAccess.tailscale.authKey} --ssh
    '';
  };

  # ========== BACKUP SUPPORT ==========
  # USB device support for backups
  services.udisks2.enable = true;
}