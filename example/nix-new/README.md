# JSON-Based Configuration Management Architecture

This directory demonstrates a robust solution for managing NixOS configuration that solves the core challenges of **parsing current state**, **generating new configurations**, and **handling rollbacks**.

## The Problem

Your current system needs to:
1. ‚úÖ **Generate configs** - Go templates ‚Üí NixOS configuration  
2. ‚ùå **Parse current state** - Extract settings from existing config files (brittle regex)
3. ‚ùå **Handle rollbacks** - Restore previous configurations reliably

The existing approach uses:
- Go templates scattered throughout a 212-line configuration file
- Complex regex parsing to extract current values (`parseBooleanSetting`, `parseStringSetting`)
- Simple `.old` backup system (only one level of rollback)

## The Solution: JSON + Nix Import

**Architecture**: Separate data from configuration logic using JSON as the data layer.

```
/etc/nixos/
‚îú‚îÄ‚îÄ variables.json      # üìÑ All user settings (generated by Go)
‚îú‚îÄ‚îÄ variables.nix       # üîß Simple bridge: imports JSON ‚Üí Nix
‚îú‚îÄ‚îÄ configuration.nix   # ‚öôÔ∏è  Static logic: uses imported variables  
‚îî‚îÄ‚îÄ history/
    ‚îú‚îÄ‚îÄ variables-001.json  # üìö Version history for rollback
    ‚îú‚îÄ‚îÄ variables-002.json
    ‚îú‚îÄ‚îÄ variables-003.json
    ‚îî‚îÄ‚îÄ current-version.txt # üî¢ Version tracking
```

## Key Benefits

### üéØ **Bulletproof Parsing**
- **Before**: Complex regex like `(?m)^\\s*%s\\s*=\\s*(true|false)\\s*;` 
- **After**: Standard JSON parsing: `json.Unmarshal(data, &config)`
- **Result**: No more parsing failures, formatting independence

### üìù **Simple Generation** 
- **Before**: Go templates scattered through 212-line config file
- **After**: JSON generation: `json.Marshal(config)`  
- **Result**: Clean separation of data and logic

### üîÑ **Built-in Rollback**
- **Before**: Only `.old` backup (one level)
- **After**: Unlimited versioned history + simple restoration
- **Result**: Robust rollback to any previous state

### üèóÔ∏è **Clean Architecture**
- **Before**: Template variables mixed with static configuration
- **After**: Clear separation: data (JSON) vs logic (Nix)
- **Result**: Easier to maintain, debug, and extend

## File Structure Explained

### `variables.json` - The Data Layer
```json
{
  "meta": {
    "version": "003",
    "timestamp": "2024-09-18T16:45:00Z"
  },
  "system": {
    "timeZone": "America/New_York",
    "autoUpgrade": true
  },
  "remoteAccess": {
    "tailscale": {
      "enable": true,
      "authKey": "tskey-auth-xyz"
    }
  }
}
```
- **Generated by Go** from web UI input
- **Easy to parse** back into Go structs
- **Human readable** for debugging
- **Versioned** for rollback capability

### `variables.nix` - The Bridge
```nix
{ config, pkgs, lib, ... }:
let
  varsJson = lib.importJSON ./variables.json;
in
{
  config.immichVariables = varsJson;
}
```
- **Simple template** (no user data mixed in)
- **NixOS native** JSON import
- **Type safe** variable access
- **Static file** (rarely changes)

### `configuration.nix` - The Logic Layer  
```nix
{ config, pkgs, ... }:
let
  vars = config.immichVariables;
in
{
  imports = [ ./variables.nix ];
  
  time.timeZone = vars.system.timeZone;
  services.tailscale.enable = vars.remoteAccess.tailscale.enable;
  # ... rest of config uses vars.*
}
```
- **No template variables** - pure NixOS configuration
- **Uses imported variables** from JSON
- **Static logic** - rarely needs changes
- **Clean and readable** - separated concerns

## Go Integration

### Current Pain Points Solved:

**‚ùå Before - Brittle Regex Parsing:**
```go
func parseBooleanSetting(fileContent []byte, setting string) (bool, error) {
    re := regexp.MustCompile(fmt.Sprintf(`(?m)^\\s*%s\\s*=\\s*(true|false)\\s*;`, setting))
    match := re.FindSubmatch(fileContent)
    // Complex error-prone parsing...
}
```

**‚úÖ After - Simple JSON Parsing:**
```go
func LoadCurrentConfig() (*ConfigVariables, error) {
    data, err := os.ReadFile("variables.json")
    if err != nil {
        return nil, err
    }
    
    var config ConfigVariables
    return &config, json.Unmarshal(data, &config)
}
```

### Implementation Benefits:

1. **Replace `loadCurrentConfig()`**: No more regex parsing
2. **Replace `saveTmpFile()`**: No more Go templates  
3. **Add rollback functionality**: Built-in version management
4. **Improve error handling**: JSON validation vs regex failures
5. **Enable config diffs**: Compare any two JSON versions

## Migration Path

### Phase 1: Update Data Structures
```go
// Replace existing NixConfig struct
type ConfigVariables struct {
    Meta struct {
        Version     string    `json:"version"`
        Timestamp   time.Time `json:"timestamp"`
    } `json:"meta"`
    System struct {
        TimeZone    string `json:"timeZone"`
        AutoUpgrade bool   `json:"autoUpgrade"`
    } `json:"system"`
    // ... comprehensive structure
}
```

### Phase 2: Replace Template System
- Remove Go template files from `internal/templates/`
- Replace with JSON generation functions
- Update web handlers to use new structure

### Phase 3: Add Rollback Interface
- Add version listing endpoint: `GET /versions`
- Add rollback endpoint: `POST /rollback/{version}`
- Update UI with rollback functionality

### Phase 4: Update NixOS Files
- Deploy new `variables.nix` and `configuration.nix`
- Test configuration switching
- Verify rollback functionality

## Example Usage

See `go-integration-example.go` for complete implementation examples:

```go
// Read current configuration
config, err := LoadCurrentConfig()

// Generate new configuration  
newConfig, err := GenerateConfig(userSettings)

// Save with automatic versioning
err = SaveConfig(newConfig)

// List rollback options
versions, err := ListAvailableVersions()

// Rollback to previous version
err = RollbackToVersion("002")
```

## Comparison: Current vs JSON Approach

| Aspect | Current Approach | JSON Approach |
|--------|------------------|---------------|
| **Config Parsing** | Complex regex, fragile | Standard JSON, bulletproof |
| **Config Generation** | Go templates throughout | Clean JSON marshaling |
| **Rollback** | Single `.old` backup | Unlimited version history |
| **Debugging** | Template + regex issues | Readable JSON files |
| **Extension** | Modify templates + parsing | Add JSON fields |
| **Error Handling** | Regex match failures | JSON validation |
| **Maintenance** | High (complex parsing) | Low (standard libraries) |

## Testing

The approach includes comprehensive examples:

1. **`variables.json`** - Current active configuration
2. **`history/`** - Three example versions showing evolution
3. **`go-integration-example.go`** - Full implementation with examples
4. **`configuration.nix`** - Working NixOS config using JSON variables

## Future Enhancements

This architecture makes it easy to add:

- **Configuration validation**: JSON schema validation
- **Web UI diff view**: Compare configurations before applying
- **Automated rollback**: Auto-rollback on failed `nixos-rebuild`
- **Configuration templates**: Pre-defined configuration sets
- **Import/export**: Backup and restore entire configurations
- **Audit trail**: Track who made what changes when

## Conclusion

This JSON-based approach solves all three core requirements:

1. ‚úÖ **Easy parsing**: Standard JSON ‚Üí Go structs
2. ‚úÖ **Simple generation**: Go structs ‚Üí JSON 
3. ‚úÖ **Robust rollback**: Versioned JSON files

It replaces complex, brittle regex parsing and scattered template variables with a clean, maintainable architecture using standard tools. The result is more reliable, easier to debug, and much simpler to extend.

**Perfect for your use case**: Provides all the parsing and rollback capabilities you need while keeping the single-file NixOS configuration approach that works well for your project size.